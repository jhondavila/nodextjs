<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Nodext-database-query-Base'>/**
</span> * 
 */
Nodext.define(&quot;Nodext.database.query.Base&quot;, {
    // extend: &#39;Nodext.database.query.Protect&#39;,
    extend: &quot;Ext.Base&quot;,
    mixins: [
        &quot;Nodext.database.query.Util&quot;,
        &quot;Nodext.database.query.Protect&quot;
    ],
<span id='Nodext-database-query-Base-property-S-configPrefixed'>    $configPrefixed: false,
</span><span id='Nodext-database-query-Base-method-constructor'>    constructor: function (config) {
</span>        config = config || {};
        Nodext.apply(this, config);
        this.initConfig(config);
        this.callParent(arguments);
    },
<span id='Nodext-database-query-Base-property-regexp'>    regexp: {
</span>        join: /([\(\)\[\]\w\.&#39;-]+)(\s*[^\&quot;\[`&#39;\w]+\s*)(.+)/i,
        // case: /([\[\]\w\.&#39;-(::| )]+)(\s*[^\&quot;\[`&#39;\w]+\s*)(.+)/i,
        case: /([\(\)\[\]\w\.&#39;-]+)(\s*[^\&quot;\[`&#39;\w]+\s*)(.+)/i
    },
<span id='Nodext-database-query-Base-property-aggregateType'>    aggregateType: [&#39;MAX&#39;, &#39;MIN&#39;, &#39;AVG&#39;, &#39;SUM&#39;],
</span><span id='Nodext-database-query-Base-property-orderByDirection'>    orderByDirection: [&#39;ASC&#39;, &#39;DESC&#39;],
</span><span id='Nodext-database-query-Base-property-joinArray'>    joinArray: [&#39;LEFT&#39;, &#39;RIGHT&#39;, &#39;FULL OUTER&#39;, &#39;OUTER&#39;, &#39;INNER&#39;, &#39;LEFT OUTER&#39;, &#39;RIGHT OUTER&#39;, &#39;CROSS&#39;],
</span><span id='Nodext-database-query-Base-property-ilikeDefaultActive'>    ilikeDefaultActive: true,
</span><span id='Nodext-database-query-Base-property-executeTypeTrans'>    executeTypeTrans: [&quot;trans_start&quot;, &quot;trans_complete&quot;, &quot;trans_commit&quot;, &quot;trans_rollback&quot;],
</span><span id='Nodext-database-query-Base-property-executeTypeCrud'>    executeTypeCrud: [&quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;, &quot;upsert&quot;],
</span><span id='Nodext-database-query-Base-property-keyUNION'>    keyUNION: &quot;UNION&quot;,
</span><span id='Nodext-database-query-Base-property-keyBreakLine'>    keyBreakLine: &quot;\n&quot;,
</span>
<span id='Nodext-database-query-Base-method-frompivot'>    frompivot: function (qObj, select) {
</span>        var data = select.data;
        var cols = select.cols;
        var output = select.output;
        var alias = select.alias || &quot;ct&quot;;

        var ssData = this.createQueryObject(data), ssCols, qData, qCols, keys, query;
        this.applyBasicCompile(ssData);
        qData = this._compile_select(ssData.QB);

        if (cols) {
            ssCols = this.createQueryObject(cols);
            this.applyBasicCompile(ssCols);
            qCols = this._compile_select(ssCols.QB);
        }

        keys = [];
        for (var o in output) {
            keys.push(this.protect_identifiers(ssData.QB, o, true, null, false) + &quot; &quot; + output[o]);
        }
        if (cols) {
            query = Nodext.String.format(&quot;crosstab \n($$ {0} $$,\n $${1}$$) as {2} \n({3})&quot;, qData, qCols, alias, keys.join(&quot;,&quot;));
        } else {
            query = Nodext.String.format(&quot;crosstab \n($$ {0} $$) as {1} \n({2})&quot;, qData, alias, keys.join(&quot;,&quot;));
        }
        qObj.QB.qb_from.push(query || &quot;error&quot;);
    },
<span id='Nodext-database-query-Base-method-subSelect'>    subSelect: function (qObj, select) {
</span>        var subselect = this.createQueryObject(select);
        this.applyBasicCompile(subselect);
        var query = this._compile_select(subselect.QB);
        if (query) {
            qObj.QB.qb_select.push(&quot;(&quot; + query + &quot;)&quot; + (select.alias || select.as ? &quot; as &quot; + this.escape_identifiers(select.alias || select.as) : &quot;&quot;));
            qObj.QB.qb_no_escape.push(false);
        }
        subselect.destroy();
        query = subselect = null;
        return query;
    },
<span id='Nodext-database-query-Base-method-selectTemplate'>    selectTemplate: function (qObj, select) {
</span>        var tpl = select.tpl,
            alias = select.alias,
            replace = select.replace, result;
        var compiles = [tpl];
        for (var p in replace) {
            compiles.push(this.tplProccessItem(replace[p]));
        }
        result = Nodext.String.format.apply(null, compiles) || &quot;&quot;;
        result += alias ? &quot; as &quot; + this.protect_identifiers(qObj.QB, alias, false, this.protectIdentifiers) : &quot;&quot;;
        qObj.QB.qb_select.push(result);
        qObj.QB.qb_no_escape.push(false);
    },
<span id='Nodext-database-query-Base-method-tplProccessItem'>    tplProccessItem: function (item) {
</span>        var qObj, partQuery, value, cols, col;
        qObj = this.createQueryObject(item);
        if (item.type === &quot;case&quot;) {
            partQuery = this.selectCase(qObj, item);
        } else if (item.type === &quot;select&quot;) {
            this.applyBasicCompile(qObj);
            partQuery = this._compile_select(qObj.QB);
        } else if (item.columns) {
            var value = item.columns;
            if (!Array.isArray(value)) {
                return false;
            }
            cols = [];
            value.forEach(function (v) {
                if (typeof v === &quot;string&quot;) {
                    col = this.selectTplCols(qObj, v);
                } else if (Array.isArray(v)) {
                    col = this.selectTplCols.apply(this, [qObj].concat(v));
                } else if (Nodext.isObject(v)) {
                    type = this.mapSelectFn[v.type || &quot;selectTplCols&quot;];
                    col = this[type].apply(this, [qObj].concat(v));
                } else if (Number.isInteger(v)) {
                    col = this.selectTplCols(qObj, &quot;cast(&quot; + this.escape(v) + &quot; as integer)&quot;, false);
                } else if (!isNaN(v)) {
                    col = this.selectTplCols(qObj, &quot;cast(&quot; + v + &quot; as numeric)&quot;, false);
                }
                cols.push(col);
            }, this);
            partQuery = cols.join(&quot;, &quot;);
        }
        qObj.destroy();
        qObj = value = cols = col = null;


        return partQuery;
    },
<span id='Nodext-database-query-Base-method-selectTplCols'>    // selectTemplate: function (qObj, select) {
</span>    //     var querys = select.querys || [],
    //         result;
    //     if (!Array.isArray(querys)) {
    //         querys = [querys];
    //     }
    //     var compiles = [],
    //         selectCols = select.select, col, cols;
    //     // debugger
    //     if (selectCols) {
    //         if (typeof selectCols === &#39;string&#39;) {
    //             selectCols = [selectCols];
    //         }
    //         col, cols = [];
    //         for (var x = 0; x &lt; selectCols.length; x++) {
    //             col = selectCols[x];
    //             if (Array.isArray(col)) {
    //                 col.splice(0, 0, qObj.QB);
    //                 cols.push(this.selectTplCols.apply(this, col));
    //             } else {
    //                 cols.push(this.selectTplCols(qObj.QB, col));
    //             }
    //         }
    //         compiles.push(cols.join(&quot;, &quot;));
    //     }
    //     result = this.resolveTemplate(select.tpl, querys, compiles);
    //     result = select.alias ? result + &quot; as &quot; + select.alias : result;
    //     qObj.QB.qb_select.push(result);
    //     qObj.QB.qb_no_escape.push(false);
    //     querys = compiles = cols = selectCols = null;
    // },
    selectTplCols: function (QBI, select, escape, separator) {
        select = (typeof select === &quot;undefined&quot;) ? &#39;*&#39; : select;
        escape = (typeof escape === &quot;undefined&quot;) ? true : escape;
        separator = (typeof separator === &quot;undefined&quot;) ? null : separator;
        if (typeof select === &#39;string&#39;) {
            if (separator === null) {
                select = select.split(&quot;,&quot;);
            } else {
                select = select.split(separator);
            }
        } else if (select === null) {
            select = [&quot;null&quot;];
        }
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }
        list = [];
        var me = this;
        select.forEach(function (val) {
            val = val.trim();
            if (val !== &#39;&#39;) {
                val = me.protect_identifiers(QBI, val, false, escape);
                list.push(val);
            }
        });
        return list.join(&quot;, &quot;);
    },
<span id='Nodext-database-query-Base-method-resolveTemplate'>    resolveTemplate: function (tpl, querys, compiles) {
</span>        var x, subselect, queryStr;
        compiles = compiles || [];
        compiles.splice(0, 0, tpl);
        for (x = 0; x &lt; querys.length; x++) {
            subselect = this.createQueryObject(querys[x]);
            this.applyBasicCompile(subselect);
            queryStr = this._compile_select(subselect.QB);
            compiles.push(queryStr);
        }
        return Nodext.String.format.apply(null, compiles) || &quot;&quot;;
    },
<span id='Nodext-database-query-Base-method-fromselect'>    fromselect: function (qObj, select) {
</span>        var query, subselect;
        if (select.query) {
            query = select.query;
            qObj.QB.qb_from.push(&quot;(&quot; + query + &quot;)&quot; + (select.alias || select.as ? &quot; as &quot; + this.escape_identifiers(select.alias || select.as) : &quot;&quot;));
        } else {
            subselect = this.createQueryObject(select), query;
            this.applyBasicCompile(subselect);
            query = this._compile_select(subselect.QB);
            if (query) {
                qObj.QB.qb_from.push(&quot;(&quot; + query + &quot;)&quot; + (select.alias || select.as ? &quot; as &quot; + this.escape_identifiers(select.alias || select.as) : &quot;&quot;));
            }
            subselect.destroy();
        }
        query = subselect = null;
    },
<span id='Nodext-database-query-Base-method-whereinselect'>    whereinselect: function (qObj, select) {
</span>        var x, subselect, v;
        if (Nodext.isArray(select.union)) {
            var selects = [];
            for (x = 0; x &lt; select.union.length; x++) {
                subselect = this.createQueryObject(select.union[x]);
                this.applyBasicCompile(subselect);
                v = this._compile_select(subselect.QB);
                subselect.destroy();
                selects.push(v);
            }
            v = selects.join(this.keyBreakLine + this.keyUNION + this.keyBreakLine);
            Nodext.destroyArray();
        } else {
            subselect = this.createQueryObject(select);
            this.applyBasicCompile(subselect);
            v = this._compile_select(subselect.QB);
            subselect.destroy();
        }
        return v;
    },
<span id='Nodext-database-query-Base-method-getCacheSelect'>    getCacheSelect: function (select) {
</span>        var qObj = this.createQueryObject({
            select: select
        });
        this.applyBasicCompile(qObj);
        var v = this._compile_select_cache(qObj.QB);
        qObj.destroy();
        return v;
    },
<span id='Nodext-database-query-Base-method-select'>    select: function (qObj, select, escape, separator) {
</span>        select = (typeof select === &quot;undefined&quot;) ? &#39;*&#39; : select;
        escape = (typeof escape === &quot;undefined&quot;) ? true : escape;
        separator = (typeof separator === &quot;undefined&quot;) ? null : separator;
        if (typeof select === &#39;string&#39;) {
            if (separator === null) {
                select = select.split(&quot;,&quot;);
            } else {
                select = select.split(separator);
            }
        } else if (select === null) {
            select = [&quot;null&quot;];
        }
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }
        select.forEach(function (val) {
            val = val.trim();
            if (val !== &#39;&#39;) {
                qObj.QB.qb_select.push(val);
                qObj.QB.qb_no_escape.push(escape);
            }
        });
        // return this;
    },
<span id='Nodext-database-query-Base-method-selectCase'>    selectCase: function (qObj, sCase) {
</span>        // debugger
        var me = this, QBI = qObj.QB;
        var escape = (typeof sCase.escape === &quot;undefined&quot;) ? true : sCase.escape;
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }
        var cond = &quot;\nCASE &quot;, v;
        if (sCase.conditions &amp;&amp; Array.isArray(sCase.conditions)) {
            sCase.conditions.forEach(function (item) {
                if (item.escapeValue) {
                    v = this.escape(item.then);
                } else {
                    v = item.then;
                }
                cond += Nodext.String.format(&quot;\nWHEN {0} THEN {1}&quot;, me.escapeCase(QBI, escape, item.when), v);
            }, this);
        }
        if (sCase.default &amp;&amp; Nodext.isObject(sCase.default)) {
            cond += Nodext.String.format(&quot;\nELSE {0}&quot;, sCase.default.then);
        }
        cond += &quot;\nEND&quot;;
        if (sCase.tpl &amp;&amp; sCase.querys) {
            var compiles = [];
            compiles.push(cond);
            cond = this.resolveTemplate(sCase.tpl, sCase.querys, compiles);
        }
        sCase.alias ? cond += &quot; &quot; + sCase.alias : undefined;
        QBI.qb_select.push(cond);
        QBI.qb_no_escape.push(false);
        QBI = null;
        return cond;
    },
<span id='Nodext-database-query-Base-method-escapeCase'>    escapeCase: function (QBI, escape, cond) {
</span>
        var me = this;
        if (escape) {
            var match;
            if ((match = /([\(\w\.]+)([\W\s\)]+)(.+)/.exec(cond))) {
                match[1] = me.protect_identifiers(QBI, match[1]);
                // debugger

                if (escape) {
                    match[3] = !me._has_operator(match[3]) ? me.escape(match[3]) : match[3];
                }
                cond = match[1] + match[2] + match[3];
            }
        }
        var m = me.stringMatchAll(cond, /\sAND\s|\sOR\s/ig), i, c, s, temp, newcond, x;
        if (m) {
            for (x = 0; x &lt; m.length; x++) {
                m[x].push(m[x].index);
            }
            m = [m];
        }
        var newcond = &#39;&#39;;
        if (escape === true &amp;&amp; !!m) {

            m[0].push([&#39;&#39;, cond.length]);
            for (i = 0, c = (m[0].length), s = 0; i &lt; c; s = m[0][i][1] + (m[0][i][0].length), i++) {
                temp = me.substr(cond, s, (m[0][i][1] - s));
                if ((match = this.regexp.case.exec(temp))) {
                    // debugger

                    newcond += me.protect_identifiers(QBI, match[1], false, escape);
                    newcond += match[2];
                    if (escape) {
                        newcond += !me._has_operator(match[3]) ? me.escape(match[3]) : match[3];
                    } else {
                        newcond += match[3];
                    }
                } else {
                    newcond += temp;
                }
                newcond += m[0][i][0];
            }
        } else {
            newcond = cond;
            //            return 
        }

        return newcond;
    },
<span id='Nodext-database-query-Base-method-selectMax'>    selectMax: function (qObj, select) {
</span>        return this._max_min_avg_sum(qObj, select, &#39;MAX&#39;);
    },
<span id='Nodext-database-query-Base-method-selectMin'>    selectMin: function (qObj, select, alias) {
</span>        return this._max_min_avg_sum(qObj, select, &#39;MIN&#39;);
    },
<span id='Nodext-database-query-Base-method-selectAvg'>    selectAvg: function (qObj, select, alias) {
</span>        return this._max_min_avg_sum(qObj, select, &#39;AVG&#39;);
    },
<span id='Nodext-database-query-Base-method-selectSum'>    selectSum: function (qObj, select, alias) {
</span>        return this._max_min_avg_sum(qObj, select, &#39;SUM&#39;);
    },
<span id='Nodext-database-query-Base-method-_max_min_avg_sum'>    _max_min_avg_sum: function (qObj, select, type, ret) {
</span>        var QBI = qObj.QB,
            escape = Nodext.isBoolean(select.escape) ? select.escape : this.protectIdentifiers,
            col = select.col || &#39;&#39;,
            alias = select.alias || &#39;&#39;;
        // debugger
        type = (typeof type === &quot;undefined&quot;) ? &#39;MAX&#39; : type;
        if (typeof col !== &quot;string&quot; || col === &#39;&#39;) {
            console.trace(&quot;select no es una cadena/select vacio&quot;);
        }
        if (!Nodext.Array.contains(this.aggregateType, type)) {
            console.trace(&quot;el tipo de funcion agrupador &quot; + type + &quot; no es valido&quot;);
        }
        if (alias === &#39;&#39;) {
            alias = this._create_alias_from_table(col.trim());
        }
        var sql;
        if (escape) {
            sql = type + &#39;(&#39; + this.protect_identifiers(QBI, col.trim()) + &#39;)&#39; + (alias ? &quot; AS &quot; + this.escape_identifiers(alias.trim()) : &quot;&quot;);
        } else {
            sql = type + &#39;(&#39; + col.trim() + &#39;) &#39; + (alias ? &quot; AS &quot; + alias.trim() : &quot;&quot;);
        }
        // if (ret) {
        //     return sql;
        // } else {
        QBI.qb_select.push(sql);
        QBI.qb_no_escape.push(false);
        QBI = null;
        return sql;
        //     return this;
        // }
    },
<span id='Nodext-database-query-Base-method-_create_alias_from_table'>    _create_alias_from_table: function (item) {
</span>        if (item.indexOf(&#39;.&#39;) !== -1) {
            item = item.split(&#39;.&#39;);
            return (item.length &gt; 0) ? item[item.length - 1] : false;
        }
        return item;
    },
<span id='Nodext-database-query-Base-method-distinct'>    distinct: function (qObj, val) {
</span>        val = (typeof val === &quot;undefined&quot;) ? true : val;
        qObj.QB.qb_distinct = (typeof val === &#39;boolean&#39;) ? val : true;
    },
<span id='Nodext-database-query-Base-method-from'>    from: function (qObj, from_q, quote, separator) {
</span>        var me = this;
        separator = separator || &quot;,&quot;;
        quote = (typeof quote === &quot;undefined&quot;) ? this.protectIdentifiers : quote;
        var QBI = qObj.QB;
        from_q = from_q instanceof Array ? from_q : [from_q];
        from_q.forEach(function (val) {
            if (val.indexOf(separator) !== -1) {
                val.split(separator).forEach(function (v) {
                    v = v.trim();
                    me._track_aliases(QBI, v, separator);
                    if (quote === true) {
                        v = me.protect_identifiers(QBI, v, true, null, false);
                        QBI.qb_from.push(v);
                    } else {
                        QBI.qb_from.push(v);
                    }
                });
            } else {
                val = val.trim();
                me._track_aliases(QBI, val, separator);
                if (quote === true) {
                    val = me.protect_identifiers(QBI, val, true, null, false);
                    QBI.qb_from.push(val);
                } else {
                    QBI.qb_from.push(val);
                }
            }
        });
        me = QBI = null;
        return me;
    },
<span id='Nodext-database-query-Base-method-_track_aliases'>    _track_aliases: function (QBI, table, separator) {
</span>        var me = this;
        separator = separator || &quot;,&quot;;
        if (Nodext.isArray(table)) {
            table.forEach(function (t) {
                me._track_aliases(t);
            });
            return;
        }

        // Does the string contain a comma?  If so, we need to separate
        // the string into discreet statements

        if (table.indexOf(separator) !== -1) {
            return me._track_aliases(table.split(separator));
        }

        // if a table alias is used we can recognize it by a space
        if (table.indexOf(&#39; &#39;) !== -1) {
            // if the alias is written with the AS keyword, remove it
            table = me.preg_replace(&#39;/\s+AS\s+/i&#39;, &#39; &#39;, table);
            // Grab the alias
            table = me.strrchr(table, &#39; &#39;).trim();
            // Store the alias, if it doesn&#39;t already exist
            if (!Nodext.Array.contains(QBI.qb_aliased_tables, table)) {
                QBI.qb_aliased_tables.push(table);
            }
        }
    },
<span id='Nodext-database-query-Base-method-stringMatchAll'>    stringMatchAll: function (string, regexp) {
</span>        var matches = [];
        if (typeof string === &quot;string&quot;) {
            string.replace(regexp, function () {
                var arr = ([]).slice.call(arguments, 0);
                var extras = arr.splice(-2);
                arr.index = extras[0];
                arr.input = extras[1];
                matches.push(arr);
            });
        }
        return matches.length ? matches : null;
    },
<span id='Nodext-database-query-Base-method-join'>    join: function (qObj, table, cond, type, escape) {
</span>        //        console.log(type);
        type = (typeof type === &quot;undefined&quot;) ? &#39;&#39; : type;
        escape = (typeof escape === &quot;undefined&quot;) ? false : escape;
        //        quote = (typeof quote === &quot;undefined&quot;) ? false : quote;
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }
        var me = this;
        var QBI = qObj.QB;
        if (type !== &#39;&#39;) {
            type = type.trim().toUpperCase();
            if (!Nodext.Array.contains(this.joinArray, type)) {
                type = &#39;&#39;;
            } else {
                type += &#39; &#39;;
            }
        }
        //        console.log(table);
        // Extract any aliases that might exist. We use this information
        // in the protect_identifiers to know whether to add a table prefix
        me._track_aliases(QBI, table);
        if (escape) {
            var match;
            // Strip apart the condition and protect the identifiers
            if ((match = /([\w\.]+)([\W\s]+)(.+)/.exec(cond))) {
                match[1] = me.protect_identifiers(QBI, match[1]);
                match[3] = me.protect_identifiers(QBI, match[3]);
                cond = match[1] + match[2] + match[3];
            }
        }
        //        console.log(cond);
        var m = me.stringMatchAll(cond, /\sAND\s|\sOR\s/ig), i, c, s, temp, newcond, x;
        if (m) {
            for (x = 0; x &lt; m.length; x++) {
                m[x].push(m[x].index);
            }
            m = [m];
        }
        //        console.log(m);
        if (escape === true &amp;&amp; !!m) {
            var newcond = &#39;&#39;;
            m[0].push([&#39;&#39;, cond.length]);
            for (i = 0, c = (m[0].length), s = 0; i &lt; c; s = m[0][i][1] + (m[0][i][0].length), i++) {
                temp = me.substr(cond, s, (m[0][i][1] - s));

                newcond += (match = this.regexp.join.exec(temp)) ? me.protect_identifiers(QBI, match[1]) + match[2] + me.protect_identifiers(QBI, match[3]) : temp;

                newcond += m[0][i][0];
            }
            cond = &#39; ON &#39; + newcond;
        }
        else if (escape === true &amp;&amp; (match = this.regexp.join.exec(cond))) {
            cond = &#39; ON &#39;.me.protect_identifiers(QBI, match[1]) + match[2] + me.protect_identifiers(QBI, match[3]);
        } else if (!me._has_operator(cond)) {
            if (type === &quot;CROSS&quot; + &#39; &#39;) {
                cond = &#39;&#39;;
            } else {
                cond = &#39; USING (&#39; + (escape ? me.escape_identifiers(cond) : cond) + &#39;)&#39;;
            }
        } else {
            cond = &#39; ON &#39; + cond;
        }
        if (escape === true) {
            table = me.protect_identifiers(QBI, table, true, null, false);
        }
        QBI.qb_join.push(type + &#39; JOIN &#39; + table + cond);
        QBI = null;
        return me;
    },
<span id='Nodext-database-query-Base-method-where'>    where: function (qObj, item) {
</span>        return this._wh(qObj, &#39;qb_where&#39;, &#39;AND &#39;, item);
    },
<span id='Nodext-database-query-Base-method-or_where'>    or_where: function (qObj, item) {
</span>        return this._wh(qObj, &#39;qb_where&#39;, &#39;OR &#39;, item);
    },
<span id='Nodext-database-query-Base-method-_wh'>    _wh: function (qObj, qb_key, type, item) {
</span>        // debugger
        // if (new Date(item.value)) {
        //     debugger    
        // }
        var escape;
        var me = this;
        var QBI = qObj.QB,
            qb_cache_key = (qb_key === &#39;qb_having&#39;) ? &#39;qb_cache_having&#39; : &#39;qb_cache_where&#39;;
        type = type || &#39;AND &#39;;
        if (item.field) {
            escape = item.escape;
            var obj = {};
            obj[item.field] = item.value;
            item = obj;
        }
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }
        var prefix, fake_escape = false;
        Nodext.Object.each(item, function (k, v) {
            prefix = (QBI[qb_key].length === 0 &amp;&amp; QBI[qb_cache_key].length === 0) ? me._group_get_type(QBI, &#39;&#39;) : me._group_get_type(QBI, type);
            if (typeof v === &quot;string&quot; || typeof v === &quot;number&quot;) {

                if (escape === true) {
                    k = me.protect_identifiers(QBI, k, false, escape);
                    v = &#39; &#39; + me.escape(v);
                }
                if (!me._has_operator(k)) {
                    k += &#39; = &#39;;
                }

            } else if (Nodext.isObject(v)) {
                v = &quot;(&quot; + me.whereinselect(null, v) + &quot;)&quot;;
                if (escape === true) {
                    k = me.protect_identifiers(QBI, k, false, escape);
                }
                if (!me._has_operator(k)) {
                    k += &#39; = &#39;;
                }
            } else if (typeof v === &quot;undefined&quot;) {
                k = me.protect_identifiers(QBI, k, false, escape);
                v = &#39;&#39;;
            } else if (v === null) {
                if (escape === true) {
                    k = me.protect_identifiers(QBI, k, false, escape);
                    v = &#39; &#39; + me.escape(v);
                }
                if (!me._has_operator(k)) {
                    k += &#39; is &#39;;
                }
            }
            QBI[qb_key].push({
                &#39;condition&#39;: prefix + k + v,
                &#39;escape&#39;: fake_escape
            });
        });
        QBI = null;
    },
<span id='Nodext-database-query-Base-method-_group_get_type'>    _group_get_type: function (QBI, type) {
</span>        if (QBI.qb_where_group_started) {
            type = &#39;&#39;;
            QBI.qb_where_group_started = false;
        }
        return type;
    },
<span id='Nodext-database-query-Base-method-where_in'>    where_in: function (qObj, item) {
</span>        return this._where_in(qObj, false, &#39;AND &#39;, item);
    },
<span id='Nodext-database-query-Base-method-or_where_in'>    or_where_in: function (qObj, item) {
</span>        return this._where_in(qObj, false, &#39;OR &#39;, item);
    },
<span id='Nodext-database-query-Base-method-where_not_in'>    where_not_in: function (qObj, item) {
</span>        return this._where_in(qObj, true, &#39;AND &#39;, item);
    },
<span id='Nodext-database-query-Base-method-or_where_not_in'>    or_where_not_in: function (qObj, item) {
</span>        return this._where_in(qObj, true, &#39;OR &#39;, item);
    },
<span id='Nodext-database-query-Base-method-_where_in'>    _where_in: function (qObj, not, type, item) {
</span>        if (!item.field || !item.value) {
            return this;
        }
        var values = item.value;
        not = (typeof not === &quot;undefined&quot;) ? false : not;
        type = (typeof type === &quot;undefined&quot;) ? &#39;AND &#39; : type;
        var escape = item.escape;
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }
        var me = this, key;
        var QBI = qObj.QB, where_in, where_in_q, prefix;
        not = (not) ? &#39; NOT&#39; : &#39;&#39;;
        prefix = (QBI.qb_where.length === 0) ? this._group_get_type(QBI, &#39;&#39;) : this._group_get_type(QBI, type);

        if (Nodext.isObject(values)) {
            escape = false;
            where_in_q = this.whereinselect(null, values);
            key = prefix + item.field + not;
        } else {
            if (!Array.isArray(values)) {
                values = [values];
            }
            where_in = [];
            values.forEach(function (item) {
                where_in.push(me.escape(item));
            });
            where_in_q = where_in.join(&#39;, &#39;);
            Nodext.destroyArray(where_in);
            escape = false;
            key = me.protect_identifiers(QBI, prefix + item.field + not, false, escape);
        }

        QBI.qb_where.push({
            condition: key + &#39; IN(&#39; + where_in_q + &#39;)&#39;,
            escape: escape
        });
        Nodext.destroyArray(where_in);
        QBI = where_in = where_in_q = null;
        return me;
    },
<span id='Nodext-database-query-Base-method-like'>    like: function (qObj, item) {
</span>        return this._like(qObj, &#39;AND &#39;, &#39;&#39;, item);
    },
<span id='Nodext-database-query-Base-method-not_like'>    not_like: function (qObj, item) {
</span>        return this._like(qObj, &#39;AND &#39;, &#39;NOT&#39;, item);
    },
<span id='Nodext-database-query-Base-method-or_like'>    or_like: function (qObj, item) {
</span>        return this._like(qObj, &#39;OR &#39;, &#39;&#39;, item);
    },
<span id='Nodext-database-query-Base-method-or_not_like'>    or_not_like: function (qObj, item) {
</span>        return this._like(qObj, &#39;OR &#39;, &#39;NOT&#39;, item);
    },
<span id='Nodext-database-query-Base-method-_like'>    _like: function (qObj, type, not, item) {
</span>        //        console.log(item);
        var match = item.hasOwnProperty(&quot;value&quot;) ? item.value : &#39;&#39;;
        var side = item.hasOwnProperty(&quot;side&quot;) ? item.side : &#39;both&#39;;
        var escape = item.escape;
        var field = item.field;
        var ilike = item.hasOwnProperty(&quot;ilike&quot;) ? item.ilike : this.ilikeDefaultActive;
        type = (typeof type === &quot;undefined&quot;) ? &#39;AND &#39; : type;
        not = (typeof not === &quot;undefined&quot;) ? &#39;&#39; : not;

        var me = this;
        var QBI = qObj.QB, prefix, like_statement;
        if (!Nodext.isObject(field)) {
            var obj = {};
            obj[field] = match;
            field = obj;
        }

        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }

        side = side.toLowerCase();
        var like_type = &quot;LIKE&quot;;
        if (ilike) {
            like_type = &quot;ILIKE&quot;;
        }

        Nodext.Object.each(field, function (k, v) {
            prefix = (QBI.qb_where.length === 0 &amp;&amp; QBI.qb_cache_where.length === 0) ? me._group_get_type(QBI, &#39;&#39;) : me._group_get_type(QBI, type);
            if (v.toString) {
                v = v.toString();
            }
            v = me.escape_like_str(v);
            if (item.cast) {
                k = k + &quot; ::varchar&quot;;
            }
            if (side === &#39;none&#39;) {
                like_statement = Nodext.String.format(&quot;{0} {1} {2} {3} &#39;{4}&#39;&quot;, prefix, k, not, like_type, v);
            } else if (side === &#39;before&#39;) {
                like_statement = Nodext.String.format(&quot;{0} {1} {2} {3} &#39;%{4}&#39;&quot;, prefix, k, not, like_type, v);
            } else if (side === &#39;after&#39;) {
                like_statement = Nodext.String.format(&quot;{0} {1} {2} {3} &#39;{4}%&#39;&quot;, prefix, k, not, like_type, v);
            } else {
                like_statement = Nodext.String.format(&quot;{0} {1} {2} {3} &#39;%{4}%&#39;&quot;, prefix, k, not, like_type, v);
            }
            if (me.likeEscapeStr !== &#39;&#39;) {
                like_statement += Nodext.String.format(me.likeEscapeStr, me.likeEscapeChr);
            }
            QBI.qb_where.push({
                condition: like_statement,
                escape: escape
            });
        });
        QBI = null;
        return me;
    },
<span id='Nodext-database-query-Base-method-or_group_start'>    or_group_start: function (qObj) {
</span>        return this.group_start(qObj, &#39;&#39;, &#39;OR &#39;);
    },
<span id='Nodext-database-query-Base-method-not_group_start'>    not_group_start: function (qObj) {
</span>        return this.group_start(qObj, &#39;NOT &#39;, &#39;AND &#39;);
    },
<span id='Nodext-database-query-Base-method-or_not_group_start'>    or_not_group_start: function (qObj) {
</span>        return this.group_start(qObj, &#39;NOT &#39;, &#39;OR &#39;);
    },
<span id='Nodext-database-query-Base-method-group_start'>    group_start: function (qObj, not, type) {
</span>        not = (typeof not === &quot;undefined&quot;) ? &#39;&#39; : not;
        type = (typeof type === &quot;undefined&quot;) ? &#39;AND &#39; : type;
        var QBI = qObj.QB;
        type = this._group_get_type(QBI, type);
        QBI.qb_where_group_started = true;
        var prefix = (QBI.qb_where.length === 0 &amp;&amp; QBI.qb_cache_where.length === 0) ? &#39;&#39; : type;
        QBI.qb_where.push({
            condition: prefix + not + (Nodext.String.repeat(&#39; &#39;, ++QBI.qb_where_group_count)) + &#39; (&#39;,
            escape: false
        });
        QBI = null;
        return this;
    },
<span id='Nodext-database-query-Base-method-group_end'>    group_end: function (qObj) {
</span>        //        var QBI = inst._DB.QB;
        qObj.QB.qb_where_group_started = false;
        //        console.log(QBI.qb_where_group_count--);
        qObj.QB.qb_where.push({
            condition: (Nodext.String.repeat(&#39; &#39;, qObj.QB.qb_where_group_count--)) + &#39;)&#39;,
            escape: false
        });
        return this;
    },
<span id='Nodext-database-query-Base-method-group_by'>    group_by: function (qObj, by, escape, delimiter) {
</span>        by = by || [];
        escape = (typeof escape === &quot;undefined&quot;) ? true : escape;
        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }

        if (typeof by === &#39;string&#39;) {
            if (delimiter) {
                by = by.split(delimiter);
            } else {
                delimiter = &#39;,&#39;;
                by = (escape === true) ? by.split(delimiter) : [by];
            }
        }
        var me = this, fake_escape = false, QBI = qObj.QB;
        by.forEach(function (val) {
            val = val.trim();
            if (val !== &#39;&#39;) {
                if (escape) {
                    val = me.protect_identifiers(QBI, val);
                }
                QBI.qb_groupby.push({
                    field: val,
                    escape: fake_escape
                });
            }
        });
        QBI = null;
        return this;
    },
<span id='Nodext-database-query-Base-method-having'>    having: function (qObj, key, value, escape) {
</span>        return this._wh(qObj, &#39;qb_having&#39;, key, value, &#39;AND &#39;, escape);
    },
<span id='Nodext-database-query-Base-method-or_having'>    or_having: function (qObj, key, value, escape) {
</span>        return this._wh(qObj, &#39;qb_having&#39;, key, value, &#39;OR &#39;, escape);
    },
<span id='Nodext-database-query-Base-method-order_by'>    order_by: function (qObj, orderby, direction, escape, separator) {
</span>        // debugger
        direction = (typeof direction === &quot;undefined&quot;) ? &#39;&#39; : direction;
        escape = (typeof escape === &quot;undefined&quot;) ? null : escape;
        separator = (typeof separator === &quot;undefined&quot;) ? null : separator;
        var me = this, QBI = qObj.QB, match;
        direction = direction.trim().toUpperCase();
        //        console.log(direction);
        if (direction === &#39;RANDOM&#39;) {
            direction = &#39;&#39;
        } else if (me.empty(orderby)) {
            return this;
        } else if (direction !== &#39;&#39;) {
            direction = Nodext.Array.contains(this.orderByDirection, direction) ? &#39; &#39; + direction : &#39;&#39;;
        }

        if (typeof escape !== &#39;boolean&#39;) {
            escape = this.protectIdentifiers;
        }

        if (separator) {
            orderby.split(separator).forEach(function (field) {
                QBI.qb_orderby.push({
                    field: field,
                    direction: direction,
                    escape: false
                });
            });
        } else {
            separator = &quot;,&quot;;
            if (!escape) {
                QBI.qb_orderby.push({
                    field: orderby,
                    direction: direction,
                    escape: false
                });
            } else {
                orderby.split(separator).forEach(function (field) {
                    if (direction === &#39;&#39; &amp;&amp; (match = /\s+(ASC|DESC)$/i.exec(field.trim()))) {
                        QBI.qb_orderby.push({
                            field: me.substr(field, 0, match.index).trim(),
                            direction: &#39; &#39; + match[0].trim(),
                            escape: true
                        });
                    } else {
                        QBI.qb_orderby.push({
                            field: field.trim(),
                            direction: direction,
                            escape: true
                        });
                    }
                });
            }
        }
        QBI = null;
        return this;
    },
<span id='Nodext-database-query-Base-method-limit'>    limit: function (qObj, value, offset) {
</span>        offset = (typeof offset === &quot;undefined&quot;) ? 0 : offset;
        if (!isNaN(value) || !isNaN(offset)) {
            qObj.QB.qb_limit = parseInt(value);
            qObj.QB.qb_offset = parseInt(offset);
        }
        return this;
    },
<span id='Nodext-database-query-Base-method-offset'>    offset: function (qObj, offset) {
</span>        offset = (typeof offset === &quot;undefined&quot;) ? 0 : offset;
        if (!isNaN(offset)) {
            qObj.QB.qb_offset = parseInt(offset);
        }
        return this;
    },
<span id='Nodext-database-query-Base-method-_limit'>    _limit: function (QBI, sql) {
</span>        //override postgre
        return sql + &#39; LIMIT &#39; + (QBI.qb_offset ? QBI.qb_offset + &#39;, &#39; : &#39;&#39;) + QBI.qb_limit;
    },
<span id='Nodext-database-query-Base-method-_compile_select_cache'>    _compile_select_cache: function (QBI) {
</span>        var me = this, sql, x, no_escape;
        sql = &#39;&#39;;
        if (QBI.qb_select.length === 0) {
            sql += &#39;*&#39;;
        } else {
            for (x = 0; x &lt; QBI.qb_select.length; x++) {
                no_escape = typeof QBI.qb_no_escape[x] === &quot;boolean&quot; ? QBI.qb_no_escape[x] : null;
                QBI.qb_select[x] = me.protect_identifiers(QBI, QBI.qb_select[x], false, no_escape);
            }
            sql += QBI.qb_select.join(&#39;, &#39;);
        }
        return sql;
    },
<span id='Nodext-database-query-Base-method-_compile_select'>    _compile_select: function (QBI, select_override) {
</span>        select_override = (typeof select_override === &quot;undefined&quot;) ? false : select_override;
        var me = this, sql, x, no_escape;
        if (select_override !== false) {
            sql = select_override;
        } else {
            sql = !QBI.qb_distinct ? &#39;SELECT &#39; : &#39;SELECT DISTINCT &#39;;
            if (QBI.qb_select.length === 0) {
                sql += &#39;*&#39;;
            } else {
                for (x = 0; x &lt; QBI.qb_select.length; x++) {
                    no_escape = typeof QBI.qb_no_escape[x] === &quot;boolean&quot; ? QBI.qb_no_escape[x] : null;
                    //                    console.log(no_escape);
                    QBI.qb_select[x] = me.protect_identifiers(QBI, QBI.qb_select[x], false, no_escape);
                }
                sql += QBI.qb_select.join(&#39;, &#39;);
            }
        }

        if (QBI.qb_from.length &gt; 0) {
            sql += &quot;\nFROM &quot; + me._from_tables(QBI);
        }
        if (QBI.qb_join.length &gt; 0) {
            sql += &quot;\n&quot; + QBI.qb_join.join(&quot;\n&quot;);
        }

        sql += me._compile_wh(QBI, &#39;qb_where&#39;)
            + me._compile_group_by(QBI)
            + me._compile_wh(QBI, &#39;qb_having&#39;)
            + me._compile_order_by(QBI);
        // LIMIT
        if (QBI.qb_limit) {
            return me._limit(QBI, sql + &quot;\n&quot;);
        } else {
            return sql;
        }
    },
<span id='Nodext-database-query-Base-method-_is_literal'>    _is_literal: function (str) {
</span>        str = str.trim();
        if (this.empty(str) || this.ctype_digit(str)) {
            return true;
        }
        if (Nodext.isNumeric(str)) {
            return true;
        }
        if (Nodext.isBoolean(str) || str.toLowerCase() === &quot;true&quot; || str.toLowerCase() == &quot;false&quot;) {
            return true;
        }
        var _str;
        if (this.empty(_str)) {
            _str = this.escapeChar !== &#39;&quot;&#39; ? [&#39;&quot;&#39;, &quot;&#39;&quot;] : [&quot;&#39;&quot;];
        }
        return Nodext.Array.contains(_str, str[0]);
    },
<span id='Nodext-database-query-Base-method-_compile_group_by'>    _compile_group_by: function (QBI) {
</span>        var me = this;
        if (QBI.qb_groupby.length &gt; 0) {
            var i, c;
            for (i = 0, c = QBI.qb_groupby.length; i &lt; c; i++) {
                if (typeof QBI.qb_groupby[i] === &quot;string&quot;) {
                    continue;
                }
                QBI.qb_groupby[i] = (QBI.qb_groupby[i][&quot;escape&quot;] === false || me._is_literal(QBI.qb_groupby[i][&quot;field&quot;])) ?
                    QBI.qb_groupby[i][&quot;field&quot;] : me.protect_identifiers(QBI.qb_groupby[i][&quot;field&quot;]);
            }
            return &quot;\nGROUP BY &quot; + QBI.qb_groupby.join(&#39;, &#39;);
        }
        return &#39;&#39;;
    },
<span id='Nodext-database-query-Base-method-_compile_order_by'>    _compile_order_by: function (QBI) {
</span>        if (Array.isArray(QBI.qb_orderby) &amp;&amp; QBI.qb_orderby.length &gt; 0) {
            var me = this;
            for (var i = 0, c = QBI.qb_orderby.length; i &lt; c; i++) {
                if (QBI.qb_orderby[i][&#39;escape&#39;] !== false &amp;&amp; !me._is_literal(QBI.qb_orderby[i][&#39;field&#39;])) {
                    QBI.qb_orderby[i][&#39;field&#39;] = me.protect_identifiers(QBI, QBI.qb_orderby[i][&#39;field&#39;]);
                }
                QBI.qb_orderby[i] = QBI.qb_orderby[i][&#39;field&#39;] + QBI.qb_orderby[i][&#39;direction&#39;];
            }
            return QBI.qb_orderby = &quot;\nORDER BY &quot; + QBI.qb_orderby.join(&#39;, &#39;);
        } else if (typeof QBI.qb_orderby === &quot;string&quot;) {
            return QBI.qb_orderby;
        }
        return &#39;&#39;;
    },
<span id='Nodext-database-query-Base-method-_compile_wh'>    _compile_wh: function (QBI, qb_key) {
</span>        var conditions, ci, cc, me = this, matches;
        if (QBI[qb_key].length &gt; 0) {
            var i, c, op;
            for (i = 0, c = QBI[qb_key].length; i &lt; c; i++) {
                if (typeof QBI[qb_key][i] === &quot;string&quot;) {
                    continue;
                } else if (QBI[qb_key][i][&#39;escape&#39;] === false) {
                    QBI[qb_key][i] = QBI[qb_key][i][&quot;condition&quot;];
                    continue;
                }
                conditions = QBI[qb_key][i][&quot;condition&quot;].split(/(\s*AND\s+|\s*OR\s+)/ig);
                conditions.forEach(function (item) {
                    if (me.empty(item)) {
                        Nodext.Array.remove(conditions, item);
                    }
                });
                for (ci = 0, cc = conditions.length; ci &lt; cc; ci++) {
                    op = me._get_operator(conditions[ci]);
                    if (op === false) {
                        continue;
                    }
                    matches = conditions[ci].match(eval(&#39;/^(\\(?)(.*)(&#39; + me.preg_quote(op, &#39;/&#39;) + &#39;)\\s*(.*(\\?&lt;!\\)))?(\\)?)$/i&#39;));
                    if (!me.empty(matches[4])) {
                        console.trace(&quot;error _compile_wh&quot;);
                    }
                    conditions[ci] = matches[1] + me.protect_identifiers(QBI, matches[2].trim()) + &#39; &#39; +
                        matches[3].trim() + (!!matches[4] ? matches[4] : &quot;&quot;) + (!!matches[5] ? matches[5] : &quot;&quot;);
                }

                QBI[qb_key][i] = conditions.join(&#39;&#39;);
            }
            return (qb_key === &#39;qb_having&#39; ? &quot;\nHAVING &quot; : &quot;\nWHERE &quot;) + QBI[qb_key].join(&quot;\n&quot;);
        }
        return &#39;&#39;;
    },
<span id='Nodext-database-query-Base-method-_from_tables'>    _from_tables: function (QBI) {
</span>        return QBI.qb_from.join(&quot;, &quot;);
    },
<span id='Nodext-database-query-Base-method-_reset_select'>    _reset_select: function (qObj) {
</span>        console.trace(&quot;reimplementar el reset select&quot;);
        //        inst.db_reset_select();
    },
<span id='Nodext-database-query-Base-method-_get'>    _get: function (qObj, table, limit, offset) {
</span>        if (table &amp;&amp; table !== &#39;&#39;) {
            this._track_aliases(qObj.QB, table);
            this.from(qObj, table);
        }
        if (limit) {
            this.limit(qObj, limit, offset);
        }
        return this._compile_select(qObj.QB);
    },
<span id='Nodext-database-query-Base-method-_update'>    _update: function (QBI, table, values, rFields) {
</span>        var valstr = [], val;

        for (val in values) {
            valstr.push(val + &#39; = &#39; + values[val]);
        }
        return &#39;UPDATE &#39; + table + &#39; SET &#39; + valstr.join(&#39;, &#39;)
            + this._compile_wh(QBI, &#39;qb_where&#39;)
            + this._compile_order_by(QBI)
            + (QBI.qb_limit ? &#39; LIMIT &#39; + QBI.qb_limit : &#39;&#39;)
            + rFields;
    },
<span id='Nodext-database-query-Base-method-_delete'>    _delete: function (QBI, table) {
</span>        return &#39;DELETE FROM &#39; + table + &#39; &#39;
            + this._compile_wh(QBI, &#39;qb_where&#39;);
    },
<span id='Nodext-database-query-Base-method-_validate_insert'>    ////
</span>    _validate_insert: function (QBI, table) {
        if (Nodext.Object.getSize(QBI.qb_set) === 0) {
            return false;
        }
        //        console.log(QBI);
        if (table &amp;&amp; table !== &#39;&#39;) {
            QBI.qb_from[0] = table;
        } else if (!QBI.qb_from[0]) {
            return false;
        }
        return true;
    },
<span id='Nodext-database-query-Base-method-prepareUpdateData'>    prepareUpdateData: function (records, options) {
</span>        var x, i, xx, d;
        //        console.log(records);
        if (options.deleteFields &amp;&amp; options.deleteFields.length &gt; 0) {
            d = options.deleteFields;
            for (i = 0; i &lt; records.length; i++) {
                for (xx = 0; xx &lt; d.length; xx++) {
                    records[i][d[xx]] = null;
                    delete records[i][d[xx]];
                }
            }
            d = null;
        }
        if (options.replaceFields &amp;&amp; Nodext.Object.getSize(options.replaceFields) &gt; 0) {
            for (i = 0; i &lt; records.length; i++) {
                for (x in options.replaceFields) {
                    if (records[i].hasOwnProperty(x)) {
                        records[i][options.replaceFields[x]] = records[i][x];
                        records[i][x] = null;
                        delete records[i][x];
                    }
                }
            }

        }
        if (options.addFields &amp;&amp; options.addFields.length &gt; 0) {
            var obj = {};
            for (x = 0; x &lt; options.addFields.length; x++) {
                obj[options.addFields[x].field] = options.addFields[x].value;
            }
            for (x = 0; x &lt; records.length; x++) {
                Nodext.apply(records[x], obj);
            }
        }
        //        console.log(records);
        return records;
    },
<span id='Nodext-database-query-Base-method-prepareKeysInsertData'>    prepareKeysInsertData: function (keysBasic, options) {
</span>        var keys = [], x, k;
        options.deleteFields = options.deleteFields || [];
        var FieldReplace = Nodext.Object.getKeys(Nodext.Object.getSize(options.replaceFields) &gt; 0 ? options.replaceFields : {});
        for (x = 0; x &lt; keysBasic.length; x++) {
            if (!Nodext.Array.contains(options.deleteFields, keysBasic[x]) &amp;&amp; !Nodext.Array.contains(FieldReplace, keysBasic[x])) {
                keys.push({
                    field: keysBasic[x],
                    key: keysBasic[x],
                    type: &quot;send&quot;
                });
            }
        }
        if (FieldReplace.length &gt; 0) {
            for (x in options.replaceFields) {
                keys.push({
                    field: options.replaceFields[x],
                    key: options.replaceFields[x],
                    type: &quot;replace&quot;,
                    before: x
                });
            }
        }
        if (options.addFields &amp;&amp; options.addFields.length &gt; 0) {
            for (x = 0; x &lt; options.addFields.length; x++) {
                if (options.addFields[x] &amp;&amp; options.addFields[x].field) {
                    keys.push({
                        field: options.addFields[x].field,
                        key: options.addFields[x].field,
                        type: &quot;add&quot;,
                        indexAdd: x
                    });
                }
            }
        }

        if (options.validateKeys) {
            options.validateKeys(keys);
        }
        return keys;
    },
<span id='Nodext-database-query-Base-method-insertSelect'>    insertSelect: function (inst, options) {
</span>        var me = this,
            escape = options.hasOwnProperty(&quot;escape&quot;) ? options.escape : true,
            table = options.table,
            x, q;

        options.qb_keys = options.fields.length &gt; 0 ? &#39;(&#39; + options.fields.join(&#39;,&#39;) + &#39;)&#39; : &#39;&#39;;
        options.table = me.protect_identifiers(null, table, true, escape, false);

        if (options.query) {
            q = options.query;
        } else {
            var queryObj = this.createQueryObject(options);
            this.applyBasicCompile(queryObj);
            q = this._compile_select(queryObj.QB);
            queryObj.destroy();
            queryObj = null;
        }
        options.query = &quot;INSERT INTO &quot; + options.table + options.qb_keys + q;
        options.mode = &#39;select&#39;;
        options.index = -1;
        var result = me.createRsInsert(inst, options);
        x = q = escape = table = options = null;
        // if (autoRun) {
        //     console.trace(&quot;auto run insert no configurado&quot;);
        // } else {
        return result;
        // }
    },
<span id='Nodext-database-query-Base-method-insert'>    insert: function (inst, options) {
</span>        // console.log(&quot;insert&quot;);
        //        console.log(options)
        var me = this,
            escape = options.hasOwnProperty(&quot;escape&quot;) ? options.escape : true,
            table = options.table,
            x;
        // autoRun = (typeof autoRun === &quot;undefined&quot;) ? true : autoRun;
        options.mode = options.mode || &#39;basic&#39;;
        options.escape = escape;
        options.qb_keys = [];
        options.qb_set = [];

        if (!me.set_insert_batch_pgsql(options, escape)) {
            Nodext.destroyArray(options.qb_keys, options.qb_set, options.records);
            return false;
        }
        if (options.mode === &quot;basic&quot; &amp;&amp; options.qb_set.length === 0) {
            return inst.sendError({
                message: &quot;Ocurrio un error al preparar los datos a insertar&quot;
            });
        }
        if (table === &#39;&#39; || !table) {
            return inst.sendError({
                message: &quot;Error in Data Insert/No Found table name&quot;
            });
        }
        var i, total, query;
        if (Array.isArray(options.returnFields) &amp;&amp; options.returnFields.length &gt; 0) {
            var fieldsReturn = [];
            for (x = 0; x &lt; options.returnFields.length; x++) {
                fieldsReturn.push(me.protect_identifiers(null, options.returnFields[x]));
            }
            options.returnFields = &quot; returning &quot; + fieldsReturn.join(&quot;, &quot;);
            Nodext.destroyArray(fieldsReturn);
        } else {
            options.returnFields = &quot;&quot;;
        }
        options.deleteFields = null;
        options.qb_keys_string = options.qb_keys.join(&#39;, &#39;);
        options.query = [];
        options.index = -1;
        options.table = me.protect_identifiers(null, table, true, escape, false);
        if (options.mode === &quot;basic&quot;) {
            options.insertSize = options.insertSize || 100;
            for (i = 0, total = options.qb_set.length; i &lt; total; i += options.insertSize) {
                query = me._insert_batch(
                    options.table,
                    options.qb_keys_string,
                    options.qb_set.slice(i, i + options.insertSize),
                    options.returnFields);
                options.query.push(query);
            }
        } else if (options.mode === &quot;build&quot;) {
            options.insertSize = 1;
        }
        var result = me.createRsInsert(inst, options);
        x = escape = table = total = options = null;
        // if (autoRun) {
        //     console.trace(&quot;auto run insert no configurado&quot;);
        // } else {
        return result;
        // }
    },
<span id='Nodext-database-query-Base-method-_insert_batch'>    _insert_batch: function (table, keys, values, returnFields) {
</span>        return &#39;INSERT INTO &#39; + table + &#39; (&#39; + keys + &#39;) VALUES &#39; + values.join(&#39;, &#39;) + returnFields;
    },
<span id='Nodext-database-query-Base-method-set_insert_batch_pgsql'>    set_insert_batch_pgsql: function (options, escape) {
</span>        var x, escape, property, values, k, records = options.records;
        var me = this;
        //        console.log(options);
        if (!records || (records &amp;&amp; records.length === 0)) {
            return false;
        }
        var keysBasic = Nodext.Object.getKeys(records[0]);
        var keys = this.prepareKeysInsertData(keysBasic, options);
        for (x = 0; x &lt; keys.length; x++) {
            options.qb_keys.push(me.protect_identifiers(null, keys[x].key));
        }
        x = escape = property = values = null;
        if (options.mode === &quot;basic&quot;) {
            options.qb_set = [];
            this.preparedRecordsInsert(keys, records, escape, options.qb_set, options);
        } else if (options.mode === &quot;build&quot;) {
            options.arrayKeys = keys;
        }
        return this;
    },
<span id='Nodext-database-query-Base-method-pRecInsertNoEscape'>    pRecInsertNoEscape: function (row, keys, addFields) {
</span>        var values = [], k;
        for (k = 0; k &lt; keys.length; k++) {
            if (keys[k].type === &quot;send&quot;) {
                values.push(row[keys[k].field]);
            } else if (keys[k].type === &quot;replace&quot;) {
                values.push(row[keys[k].before]);
            } else if (keys[k].type === &quot;add&quot;) {
                values.push(addFields[keys[k].indexAdd].value);
            }
        }
        return values;
    },
<span id='Nodext-database-query-Base-method-buildRecInsert'>    buildRecInsert: function (row, rs) {
</span>        var values;
        if (escape) {
            values = this.pRecInsertEscape(row, rs.arrayKeys, rs.addFields);
        } else {
            values = this.pRecInsertNoEscape(row, rs.arrayKeys, rs.addFields);
        }
        var query = this._insert_batch(
            rs.table,
            rs.qb_keys_string,
            [&#39;(&#39; + values.join(&quot;,&quot;) + &#39;)&#39;],
            rs.returnFields);
        return query;
    },
<span id='Nodext-database-query-Base-method-pRecInsertEscape'>    pRecInsertEscape: function (row, keys, addFields) {
</span>        var values = [], k;
        for (k = 0; k &lt; keys.length; k++) {
            if (keys[k].type === &quot;send&quot;) {
                values.push(this.escape(row[keys[k].field]));
            } else if (keys[k].type === &quot;replace&quot;) {
                values.push(this.escape(row[keys[k].before]));
            } else if (keys[k].type === &quot;add&quot;) {
                values.push(this.escape(addFields[keys[k].indexAdd].value));
            }
        }
        return values;
    },
<span id='Nodext-database-query-Base-method-preparedRecordsInsert'>    preparedRecordsInsert: function (keys, records, escape, target, options) {
</span>        var x, row, k, values;
        if (escape === false) {
            for (x = 0; x &lt; records.length; x++) {
                row = records[x];
                values = this.pRecInsertNoEscape(row, keys, options.addFields);
                target.push(&#39;(&#39; + values.join(&quot;,&quot;) + &#39;)&#39;);
            }
        } else {
            for (x = 0; x &lt; records.length; x++) {
                row = records[x];
                values = this.pRecInsertEscape(row, keys, options.addFields);
                target.push(&#39;(&#39; + values.join(&quot;,&quot;) + &#39;)&#39;);
            }
        }
        x = row = k = values = null;
    },
<span id='Nodext-database-query-Base-method-update'>    ///////////////////////////
</span>    ///////////////////////////
    ///////////////////////////
    ///////////////////////////
    ///////////////////////////
    ///////////////////////////
    update: function (inst, options) {
        var me = this,
            queryObj = Nodext.create(&quot;Nodext.database.query.Object&quot;),
            QBI = queryObj.QB;
        var
            escape = options.escape,
            table = options.table,
            set = options.set,
            where = options.where,
            limit = options.limit;
        escape = (typeof escape === &quot;undefined&quot;) ? null : escape;
        // autoRun = (typeof autoRun === &quot;undefined&quot;) ? true : autoRun;
        if (set) {
            me.set(QBI, set);
        }
        if (me._validate_update(inst, QBI, table) !== true) {
            return false;
        }
        if (where) {
            me.__SetWhere(queryObj, where);
        }
        if (limit) {
            me.limit(inst, limit);
        }
        options.requireCompile = options.requireCompile || false;
        options.position = -1;

        // var i, total, query;
        var rFields = this._compileRfields(options.returnFields, escape);

        options.query = [me._update(QBI, me.protect_identifiers(QBI, QBI.qb_from[0], true, null, false), QBI.qb_set, rFields)];
        queryObj.destroy();
        var result = me.createRsUpdate(inst, options);
        escape = QBI = options = table = set = limit = queryObj = null;
        // if (autoRun) {
        //     console.trace(&quot;auto run update no configurado&quot;);
        //     //            var compile = [];
        //     //            compile.push(result);
        //     //            me.initQuery(inst, compile, fn);
        // } else {
        return result;
        // }

    },
<span id='Nodext-database-query-Base-method-_compileRfields'>    _compileRfields: function (rFields, escape) {
</span>        rFields = rFields || [];

        var str = &quot;&quot;;
        if (Array.isArray(rFields) &amp;&amp; rFields.length &gt; 0) {
            var fieldsReturn = [], x, field, escape;
            for (x = 0; x &lt; rFields.length; x++) {
                field = rFields[x];
                if (Ext.isString(field)) {
                    fieldsReturn.push(this.protect_identifiers(null, field, escape, null, false));
                } else if (Ext.isArray(field)) {
                    if (field[1]) {
                        fieldsReturn.push(this.protect_identifiers(null, field[0], true, field[1], false));
                    } else {
                        fieldsReturn.push(field[0]);
                    }
                }
            }
            str += &quot;returning &quot; + fieldsReturn.join(&quot;, &quot;);
            Nodext.destroyArray(fieldsReturn);
        }
        return str;
    },
<span id='Nodext-database-query-Base-method-_validate_delete'>    _validate_delete: function (inst, QBI, table) {
</span>        if (table !== &#39;&#39;) {
            QBI.qb_from[0] = table;
        } else if (!QBI.qb_from[0]) {
            inst.sendError(&quot;no ha pasado la validacion de update cod 2&quot;)
        }
        //        console.log(&quot;devolvera true&quot;);
        return true;
    },
<span id='Nodext-database-query-Base-method-delete'>    delete: function (inst, options, fn) {
</span>        var me = this,
            queryObj = Nodext.create(&quot;Nodext.database.query.Object&quot;),
            QBI = queryObj.QB,
            escape = options.escape,
            table = options.table,
            where = options.where,
            escape = (typeof escape === &quot;undefined&quot;) ? null : escape;
        // autoRun = (typeof autoRun === &quot;undefined&quot;) ? true : autoRun;
        if (me._validate_delete(inst, QBI, table) !== true) {
            return false;
        }
        if (where) {
            me.__SetWhere(queryObj, where);
        }
        options.requireCompile = options.requireCompile || false;
        options.query = [me._delete(QBI, me.protect_identifiers(QBI, QBI.qb_from[0], true, null, false))];
        queryObj.destroy();
        //        me._reset_write(QBI);
        var result = me.createRsDelete(inst, options);
        QBI = options = table = escape = where = queryObj = null;
        // if (autoRun) {
        //     console.trace(&quot;auto run update no configurado&quot;);
        // } else {
        return result;
        // }
    },
<span id='Nodext-database-query-Base-method-_reset_write'>    _reset_write: function (QBI) {
</span>        Nodext.destroyMembers(QBI, &#39;qb_set&#39;, &#39;qb_from&#39;, &#39;qb_join&#39;, &#39;qb_where&#39;, &#39;qb_orderby&#39;, &#39;qb_keys&#39;, &#39;qb_limit&#39;);
        Nodext.apply(QBI, {
            &#39;qb_set&#39;: [],
            &#39;qb_from&#39;: [],
            &#39;qb_join&#39;: [],
            &#39;qb_where&#39;: [],
            &#39;qb_orderby&#39;: [],
            &#39;qb_keys&#39;: [],
            &#39;qb_limit&#39;: false
        });
    },
<span id='Nodext-database-query-Base-property-escapeByKey'>    escapeByKey: {
</span>        left: true,
        true: true,
        both: true
    },
<span id='Nodext-database-query-Base-property-escapeByVal'>    escapeByVal: {
</span>        right: true,
        true: true,
        both: true
    },
<span id='Nodext-database-query-Base-method-set'>    set: function (QBI, key, value, escape) {
</span>        var me = this;
        if (typeof escape !== &#39;boolean&#39;) {
            gescape = this.protectIdentifiers;
        }
        QBI.qb_set = {}, escape, key, value;
        Nodext.Object.each(key, function (k, v) {
            escape = v ? v.escape || gescape : gescape;
            v = v ? v.value || v : v;
            k = k ? k.field || k : k;
            key = me.protect_identifiers(QBI, k, false, this.escapeByKey[escape] ? true : false);
            value = (this.escapeByVal[escape] ? me.escape(v) : v);
            QBI.qb_set[key] = value;
        }, this);
        return me;
    },
<span id='Nodext-database-query-Base-method-trans_start'>    trans_start: function () {
</span>        return {
            query: &quot;BEGIN&quot;,
            type: &quot;trans_start&quot;,
            requireCompile: false
        };
    },
<span id='Nodext-database-query-Base-method-trans_complete'>    trans_complete: function () {
</span>        return {
            query: &quot;END TRANSACTION&quot;,
            type: &quot;trans_complete&quot;,
            requireCompile: false
        };
    },
<span id='Nodext-database-query-Base-method-trans_commit'>    trans_commit: function () {
</span>        return {
            query: &quot;COMMIT&quot;,
            type: &quot;trans_commit&quot;,
            requireCompile: false
        };
    },
<span id='Nodext-database-query-Base-method-trans_rollback'>    trans_rollback: function () {
</span>        return {
            query: &quot;ROLLBACK&quot;,
            type: &quot;trans_rollback&quot;,
            requireCompile: false
        };
    },
<span id='Nodext-database-query-Base-method-_validate_update'>    _validate_update: function (inst, QBI, table) {
</span>        if (QBI.qb_set.length === 0) {
            inst.sendError({ success: false, message: &quot;no ha pasado la validacion de update cod 1&quot; })
        }
        if (table !== &#39;&#39;) {
            QBI.qb_from[0] = table;
        } else if (!QBI.qb_from[0]) {
            inst.sendError({ success: false, message: &quot;no ha pasado la validacion de update cod 2&quot; })
        }
        return true;
    },
<span id='Nodext-database-query-Base-method-_merge_cache'>    /**
</span>     * @deprecated
     */
    _merge_cache: function (QBI) {
        //        if (QBI.qb_cache_exists.length === 0) {
        //            return;
        //        } else if (Nodext.Array.contains(QBI.qb_cache_exists, &#39;select&#39;)) {
        //            var qb_no_escape = QBI.qb_cache_no_escape;
        //        }
        //
        //        var x, val, qb_variable, qb_cache_var, qb_new, qb_cache_exists = Nodext.Array.unique(QBI.qb_cache_exists);
        //        for (x = 0; x &lt; qb_cache_exists; x++) {
        //            val = qb_cache_exists [ x];
        //            qb_variable = &#39;qb_&#39; + val;
        //            qb_cache_var = &#39;qb_cache&#39; + val;
        //            qb_new = QBI.qb_cache_var;
        //        }
        //         foreach (array_unique($this-&gt;qb_cache_exists) as $val) { // select, from, etc.
        //            $qb_variable = &#39;qb_&#39; . $val;
        //            $qb_cache_var = &#39;qb_cache_&#39; . $val;
        //            $qb_new = $this-&gt;$qb_cache_var;
        //
        //            for ($i = 0, $c = count($this-&gt;$qb_variable); $i &lt; $c; $i++) {
        //                if (!in_array($this-&gt;{$qb_variable}[$i], $qb_new, TRUE)) {
        //                    $qb_new[] = $this-&gt;{$qb_variable}[$i];
        //                    if ($val === &#39;select&#39;) {
        //                        $qb_no_escape[] = $this-&gt;qb_no_escape[$i];
        //                    }
        //                }
        //            }
        //
        //            $this-&gt;$qb_variable = $qb_new;
        //            if ($val === &#39;select&#39;) {
        //                $this-&gt;qb_no_escape = $qb_no_escape;
        //            }
        //        }
    },
<span id='Nodext-database-query-Base-method-set_update_batch_pgsql'>    set_update_batch_pgsql: function (QBI, options, index, escape) {
</span>        var x, escape, values;
        var me = this, records;
        records = me.prepareUpdateData(options.records, options);
        //        console.log(records);
        if (!records || (records &amp;&amp; records.length === 0)) {
            return false;
        }
        var row, p, index_set, newProperty;
        QBI.qb_set = [];
        //        console.log(records);
        for (x = 0; x &lt; records.length; x++) {
            row = records[x];
            newProperty = {};
            index_set = false;
            for (p in row) {
                if (p === index) {
                    index_set = true;
                }

                newProperty[me.protect_identifiers(QBI, p, false, escape)] = (escape ? row[p] : me.escape(row[p]));

            }
            if (!index_set) {
                break;
            }

            QBI.qb_set.push(newProperty);
        }
        //        console.log(QBI.qb_set);

        //        console.log(QBI.qb_set);
        if (!index_set) {
            return false;
        }
        //        console.log(QBI);
        QBI = x = index = escape = records = row = index_set = newProperty = p = null;
        delete QBI, index_set, row, x, index, escape, records, newProperty, p;
        return this;
    },
<span id='Nodext-database-query-Base-method-updateBatch'>    updateBatch: function (inst, options) {
</span>        var me = this,
            x,
            queryObj = Nodext.create(&quot;Nodext.database.query.Object&quot;),
            QBI = queryObj.QB;
        var escape = options.escape,
            table = options.table;
        escape = (typeof escape === &quot;undefined&quot;) ? null : escape;
        // autoRun = (typeof autoRun === &quot;undefined&quot;) ? true : autoRun;
        //        console.log(options);
        if (!options.index || !options.records) {
            inst.sendError({
                message: &quot;Tanto el index como los records deben configurarse para el barrido de actualización&quot;,
                success: false
            });
            return false;
        }

        if (!me.set_update_batch_pgsql(QBI, options, options.index, escape)) {
            inst.sendError({
                message: &quot;Uno de los registros no tiene la propiedad index configurada&quot;,
                success: false
            });
            return false;
        }

        if (QBI.qb_set.length === 0) {
            inst.sendError({
                message: &quot;No se detecto registros ah actualizar&quot;
            });
            return false;
        }
        if (!table || table === &#39;&#39;) {
            if (!QBI.qb_from[0]) {
                inst.sendError({
                    message: &quot;No se configurado la tabla a actualizar&quot;
                });
                return false;
            }
            table = QBI.qb_from[0];
        }
        var chunkSize = options.chunkSize || 100, total, i, query;
        options.query = [];
        options.queryBatch = true;
        options.requireCompile = options.requireCompile || false;
        options.position = -1;
        if (options.where) {
            me.__SetWhere(queryObj, options.where);
        }
        //options.table = me.protect_identifiers(null, table, true, escape, false);
        table = me.protect_identifiers(null, table, true, escape, false);
        var index = this.protect_identifiers(QBI, options.index);
        var updateIndex = options.updateIndex ? this.protect_identifiers(QBI, options.updateIndex) : null;
        for (i = 0, total = QBI.qb_set.length; i &lt; total; i += chunkSize) {

            query = this._update_batch(queryObj, table, QBI.qb_set.slice(i, i + chunkSize), index, updateIndex);
            //            console.log(query);
            options.query.push(query);
        }
        queryObj.destroy();

        var result = me.createRsUpdate(inst, options);
        x = escape = table = QBI = options = queryObj = null;
        //        delete ;
        // if (autoRun) {
        //     console.trace(&quot;auto run insert no configurado&quot;);
        // } else {
        return result;
        // }

    },
<span id='Nodext-database-query-Base-method-_update_batch'>    _update_batch: function (queryObj, table, values, index, updateIndex) {
</span>        var ids = [], final = {};
        this.updBatchIndex(values, index, ids, final, updateIndex);
        var cases = this.updateBatchCase(final);
        if (cases === &#39;&#39;) {
            this.updBatchNoIndex(values, index, ids, final);
            cases = this.updateBatchCase(final);
        }
        this.where(queryObj, { field: index + &#39; IN(&#39; + ids.join(&#39;,&#39;) + &#39;)&#39;, value: undefined, escape: false });
        return &#39;UPDATE &#39; + table + &#39; SET &#39; + this.substr(cases, 0, -2) + this._compile_wh(queryObj.QB, &#39;qb_where&#39;);
    },
<span id='Nodext-database-query-Base-method-updateBatchCase'>    updateBatchCase: function (final) {
</span>        var cases = &#39;&#39;;
        var k, v;
        for (k in final) {
            v = final[k];
            cases += k + &quot; = CASE \n&quot;
                + v.join(&quot;\n&quot;) + &quot;\n&quot;
                + &#39;ELSE &#39; + k + &#39; END, &#39;;
        }
        return cases;
    },
<span id='Nodext-database-query-Base-method-updBatchIndex'>    updBatchIndex: function (values, index, ids, final, updateIndex) {
</span>        var x, val, field, whField;
        for (x = 0; x &lt; values.length; x++) {
            val = values[x];
            ids.push(val[index]);
            for (field in val) {
                whField = field;
                if (field !== index) {
                    if (updateIndex === field) {
                        whField = index;
                    }
                    if (!final[whField]) {
                        final[whField] = [&#39;WHEN &#39; + index + &#39; = &#39; + val[index] + &#39; THEN &#39; + val[field]];
                    } else {
                        final[whField].push(&#39;WHEN &#39; + index + &#39; = &#39; + val[index] + &#39; THEN &#39; + val[field]);
                    }

                }
            }
        }
    },
<span id='Nodext-database-query-Base-method-updBatchNoIndex'>    updBatchNoIndex: function (values, index, ids, final) {
</span>        var x, val, field;
        for (x = 0; x &lt; values.length; x++) {
            val = values[x];
            ids.push(val[index]);
            for (field in val) {
                if (!final[field]) {
                    final[field] = [&#39;WHEN &#39; + index + &#39; = &#39; + val[index] + &#39; THEN &#39; + val[field]];
                } else {
                    final[field].push(&#39;WHEN &#39; + index + &#39; = &#39; + val[index] + &#39; THEN &#39; + val[field]);
                }
            }
        }
    },
<span id='Nodext-database-query-Base-method-initQuery'>    initQuery: function (inst, config) {
</span>        if (inst.destroyed) {
            // rsg.destroy();
            return false;
        } else {
            config.inst = inst;
            config.qb = this;
            var rsg = Nodext.create(&quot;Nodext.database.ResultGroup&quot;, config);
            inst.DBCompiles.push(rsg);
            rsg.init();
        }
    }
});</pre>
</body>
</html>
